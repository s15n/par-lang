<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Par Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Par programming language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Par Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/faiface/par-lang/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Par (<span style="font-family: Noto Sans">⅋</span>) is a concurrent programming language bringing the expressive power of linear logic into practice.</p>
<p>This reference contains not only the complete grammar and specification of Par but also an extensive collection of examples, explanations and best practices.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Par is a multi-layer language with an intermediate representation in itself.</p>
<p>A simple program like</p>
<pre><code class="language-par">type HW = either { .hello_world! }

def main: HW = .hello_world!
</code></pre>
<p>is compiled to a program fully written in <em>process syntax</em>:</p>
<pre><code class="language-par"><span class="boring">type HW = either { .hello_world! }
</span><span class="boring">
</span>def main: HW = chan user {
  user.hello_world
  user!
}
</code></pre>
<p>Par is centered around concurrency and session typing, all in the framework of linear logic.
What does that mean?</p>
<ul>
<li>Types are <em>linear</em>, i.e. a value must be used exactly once.
You might know the type system of Rust, where a value must be used at most once.</li>
<li>Ultimately, everything in Par is a <em>channel</em>.
<ul>
<li>A list sends every item in order and then closes</li>
<li>A function receives its argument and becomes the result</li>
<li>An infinite stream can be signaled to either yield the next item or close</li>
</ul>
</li>
<li>Channels communicate with each other by
<ul>
<li>sending signals (the names with a dot in front)</li>
<li>sending values</li>
<li>closing each other</li>
</ul>
</li>
<li>Everything has a dual in Par: A value can be created by destroying its dual (see <a href="expressions.html#channel-expressions">channel expressions</a>)</li>
<li>This can all be abstracted away in <a href="expressions.html">expressions</a> and <a href="types.html">types</a> or be exposed as <a href="statements.html">statements</a> in <em>process syntax</em>.</li>
</ul>
<p>Putting all of this together, Par manages to be a functional language while also allowing imperative-style code and mutability.</p>
<p>For example, a mutable stack can be implemented like this (<a href="types.html#choice-types">explanation</a>):</p>
<pre><code class="language-par"><span class="boring">type Bool = either { .true!, .false! }
</span><span class="boring">type List&lt;T&gt; = recursive either { .empty!, .item(T) self }
</span><span class="boring">type Option&lt;T&gt; = either { .none!, .some T }
</span><span class="boring">
</span>type Stack&lt;Unwrap, T&gt; = iterative {
  .push(T) =&gt; self
  .pop =&gt; (Option&lt;T&gt;) self
  .unwrap =&gt; Unwrap
}

dec list_stack : [type T] [List&lt;T&gt;] Stack&lt;List&lt;T&gt;, T&gt;
def list_stack = [type T] [list] begin {
  .push(x) =&gt; let list: List&lt;T&gt; = .item(x) list in loop
  .pop =&gt; list {
    .empty! =&gt; (.none!) let list: List&lt;T&gt; = .empty! in loop,
    .item(head) tail =&gt; (.some head) let list = tail in loop
  }
  .unwrap =&gt; list
}

def main = do {
  let list: List&lt;Bool&gt; = .empty!
  let stack = list_stack(type Bool)(list)
  // stack currently represents an empty list

  // the following operations mutate stack
  stack.push(.true!)
  // stack now represents a singleton of .true!
  stack.push(.false!)
  // stack now represents a two-element list
} in stack
</code></pre>
<p>Running this in the <a href="introduction.html#getting-started">playground</a> you can push and pop elements, or inspect the underlying data using unwrap.</p>
<p>For a complete tutorial, see the <a href="introduction.html#resources">Readme</a></p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To use Par, clone the repository</p>
<pre><code class="language-sh">$ git clone https://github.com/faiface/par-lang.git
</code></pre>
<p>and run the app</p>
<pre><code class="language-sh">$ cd par-lang
$ cargo run
</code></pre>
<p>Note: If you don’t have Rust and Cargo installed, <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">do that first</a></p>
<p>This will launch the Par playground.
Some example code is already written for you.
Just press <kbd>Compile</kbd> and <kbd>Run</kbd> to run any definition from the program on the left.</p>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<p>To ask questions or discuss ideas, join our <a href="https://discord.gg/8KsypefW99">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-structure"><a class="header" href="#lexical-structure">Lexical Structure</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
LINE_COMMENT :<br />
      <code>//</code> (~\n)<sup>*</sup></p>
<p>BLOCK_COMMENT :<br />
      <code>/*</code> (BLOCK_COMMENT | ~<code>*/</code>)<sup>*</sup> <code>*/</code></p>
</blockquote>
<p>Comments have no effect on the program.</p>
<pre><code class="language-par">// This is a line comment

/*
 * And this is a multiline (block) comment.
 * The stars on the left are purely for aesthetics
 */
</code></pre>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
ID :<br />
      (ID_START ID_CONT<sup>*</sup>)<sub><em>Expect <a href="lexical.html#keywords">keywords</a></em></sub></p>
<p>ID_START :<br />
      [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code>]</p>
<p>ID_CONT :<br />
      [<code>_</code> <code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code>]</p>
</blockquote>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ID_List</em> :<br />
      ID (<code>,</code> ID)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>Some valid identifiers are:</p>
<ul>
<li><code>snake_case</code></li>
<li><code>PascalCase</code></li>
<li><code>letters123</code></li>
</ul>
<p>Some invalid identifiers are:</p>
<ul>
<li><code>chan</code>, a keyword</li>
<li><code>3D</code>, starts with a number</li>
<li><code>kebab-case</code>, same as <code>kebab - case</code></li>
</ul>
<h2 id="keywords"><a class="header" href="#keywords">Keywords</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="items.html#type-definitions">Define a type</a>, Existentials, Universals</td></tr>
<tr><td><code>dec</code></td><td><a href="items.html#definitions">Declare</a> a value</td></tr>
<tr><td><code>def</code></td><td><a href="items.html#definitions">Define</a> a value</td></tr>
<tr><td><code>chan</code></td><td><a href="expressions.html#channel-expressions">Channel expressions</a>, <a href="types.html#channel-types">Dualize types</a></td></tr>
<tr><td><code>let</code></td><td>Let <a href="expressions.html#let-expressions">expressions</a> and <a href="statements.html#let-statements">statements</a></td></tr>
<tr><td><code>do</code></td><td><a href="expressions.html#do-expressions">Do expressions</a></td></tr>
<tr><td><code>in</code></td><td><a href="expressions.html#let-expressions">Let expressions</a>, <a href="expressions.html#do-expressions">Do expressions</a></td></tr>
<tr><td><code>begin</code>, <code>loop</code></td><td><a href="./expressions/construction.html#iterative-constructions">Iterative constructions</a>, Recursive destruction (<a href="./expressions/application.html#recursive-destructions">expression</a> or <a href="./statements/commands.html#recursive-commands">statement</a>)</td></tr>
<tr><td><code>either</code></td><td><a href="types.html#either-types">Either types</a></td></tr>
<tr><td><code>recursive</code></td><td><a href="types.html#recursive-types">Recursive types</a></td></tr>
<tr><td><code>iterative</code></td><td><a href="types.html#iterative-types">Iterative types</a></td></tr>
<tr><td><code>self</code></td><td><a href="types.html#recursive-types">Recursive</a> and <a href="types.html#iterative-types">iterative</a> types</td></tr>
<tr><td><code>unfounded</code></td><td>Escape totality checker in recursive <a href="./expressions/application.html#recursive-destructions">expressions</a> and <a href="./statements/commands.html#recursive-commands">statements</a></td></tr>
</tbody></table>
</div>
<h2 id="punctuation"><a class="header" href="#punctuation">Punctuation</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>Definitions (<a href="items.html#definitions">values</a> and <a href="items.html#type-definitions">types</a>), Let <a href="expressions.html#let-expressions">expressions</a> and <a href="statements.html#let-statements">statements</a></td></tr>
<tr><td><code>:</code></td><td><a href="types.html">Type annotations</a>, Value <a href="items.html#definitions">declarations</a>, <a href="./statements/commands.html#recursive-commands">Loop labels</a></td></tr>
<tr><td><code>,</code></td><td>Various enumerations</td></tr>
<tr><td><code>!</code></td><td>Unit <a href="./types.html#the-unit-type">type</a>, <a href="./expressions/construction.html#the-unit-expression">expression</a>, <a href="./patterns.html#the-unit-pattern">pattern</a>, <a href="./statements/commands.html#the-break-command">Break command</a></td></tr>
<tr><td><code>?</code></td><td><a href="./types.html#the-bottom-type">Bottom type</a>, <a href="./statements/commands.html#the-continue-command">Continue command</a></td></tr>
<tr><td><code>.</code></td><td>Labels of either or choice types, used in various places</td></tr>
<tr><td><code>&lt;&gt;</code></td><td><a href="./statements/commands.html#link-commands">Link commands</a></td></tr>
<tr><td><code>&lt;</code></td><td>Type <a href="items.html">parameters</a> and <a href="types.html">arguments</a></td></tr>
<tr><td><code>&gt;</code></td><td>Type <a href="items.html">parameters</a> and <a href="types.html">arguments</a></td></tr>
<tr><td><code>=&gt;</code></td><td>Choice <a href="./types.html#choice-types">types</a> and <a href="./expressions/construction.html#choice-constructions">constructions</a>, Match <a href="./expressions/application.html#match-expressions">expressions</a> and <a href="./statements/commands.html#match-commands">commands</a></td></tr>
<tr><td><code>(</code> … <code>)</code></td><td>Pairs, function application</td></tr>
<tr><td><code>[</code> … <code>]</code></td><td>Functions, pair destruction</td></tr>
<tr><td><code>{</code> … <code>}</code></td><td>Either and choice types, processes</td></tr>
</tbody></table>
</div>
<h2 id="whitespace"><a class="header" href="#whitespace">Whitespace</a></h2>
<p>Whitespace in Par serves merely the purpose of separating tokens.
Whitespace characters are:</p>
<ul>
<li>The whitespace <code>' '</code></li>
<li>Tabs <code>'\t'</code>, <code>'\v'</code></li>
<li>Newline <code>'\n'</code></li>
<li>Carriage return <code>'\r'</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-files"><a class="header" href="#source-files">Source Files</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ParFile</em> :<br />
      <a href="items.html"><em>Item</em></a><sup>*</sup></p>
</blockquote>
<p>This rule is the entry point for every file written in Par.</p>
<p>Currently, every Par program consists entierely of <a href="items.html">items</a>:</p>
<ul>
<li>
<p>Type definitions</p>
<pre><code class="language-par">type TypeName = SomeType
</code></pre>
</li>
<li>
<p>Value definitions and declarations</p>
<pre><code class="language-par">// type and value together
def name: Type = value

// separate type declaration
dec name : Type
def name = value
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items"><a class="header" href="#items">Items</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Item</em> :<br />
      <a href="items.html#type-definitions"><em>TypeDefinition</em></a> <br />
   | <a href="items.html#definitions"><em>Declaration</em></a> <br />
   | <a href="items.html#definitions"><em>Definition</em></a></p>
</blockquote>
<p>Items are the primary building block of Par programs.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Declaration</em> :<br />
      <code>dec</code> <a href="./lexical.html">ID</a> <code>:</code> <a href="./types.html"><em>Type</em></a></p>
<p><em>Definition</em> :<br />
      <code>def</code> <a href="./lexical.html">ID</a> <a href="statements.html#let-statements"><em>Annotation</em></a><sup>?</sup> <code>=</code> <a href="./expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><code>def</code> defines a global definition usable throughout the file in which it was defined.
It can be used as many times as one desires, instantiating itself every time it’s used.</p>
<pre><code class="language-par">// define a static value
dec unit : !
def unit = !
// or all-in-one
def unit: ! = !

// define a function
def negate: [Bool] Bool = [b] b {
  .true! =&gt; .false!
  .false! =&gt; .true!
}

// define a function receiving types
dec pop : [type T] [List&lt;T&gt;] (Option&lt;T&gt;) List&lt;T&gt;
def pop = [type T] [list] list {
  .empty! =&gt; (.none!) .empty!
  .item(head) tail =&gt; (.some head) tail
}
</code></pre>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypeDefinition</em> :<br />
      <code>type</code> <a href="./lexical.html">ID</a> <em>TypeParameters</em><sup>?</sup> <code>=</code> <a href="./types.html"><em>Type</em></a></p>
<p><em>TypeParameters</em> :<br />
      <code>&lt;</code> <em>TypeParameter</em> (<code>,</code> <em>TypeParamter</em>)<sup>*</sup> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>TypeParameter</em> :<br />
      <a href="./lexical.html">ID</a></p>
</blockquote>
<p>A type definition defines a type alias, not a “new type”. All types in Par are structural. <!--(Proposal: Automatically add a tag in some cases for either and choice types)--></p>
<pre><code class="language-par">// simple type alias
type Boolean = Bool

// the definition of Bool
type Bool = either {
  .true!
  .false!
}

// parameterized type alias
type Option&lt;T&gt; = either {
  .none!
  .some T
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>At the heart of Par lies its type system, representing linear logic.</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Type</em> :<br />
      <a href="types.html#named-types"><em>NamedType</em></a> <br />
   | <a href="types.html#the-unit-type"><em>Unit</em></a> <br />
   | <a href="types.html#pair-types"><em>PairType</em></a> <br />
   | <a href="types.html#function-types"><em>FunctionType</em></a> <br />
   | <a href="types.html#either-types"><em>EitherType</em></a> <br />
   | <a href="types.html#choice-types"><em>ChoiceType</em></a> <br />
   | <a href="types.html#recursive-types"><em>RecursiveType</em></a> <br />
   | <a href="types.html#iterative-types"><em>IterativeType</em></a> <br />
   | <a href="types.html#existential-types"><em>ExistentialType</em></a> <br />
   | <a href="types.html#universal-types"><em>UniversalType</em></a> <br />
   | <a href="types.html#the-bottom-type"><em>Bottom</em></a> <br />
   | <a href="types.html#channel-types"><em>ChannelType</em></a> <br />
   | <em>Self</em> <!--\
> &nbsp;&nbsp; | _ReplicableType_ \
> &nbsp;&nbsp; | _TaggedType_ --></p>
<p><em>Self</em> :<br />
      <code>self</code> <a href="./statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup></p>
<p><em>TypeList</em> :<br />
      <em>Type</em> (<code>,</code> <em>Type</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>TypeArguments</em> :<br />
      <code>&lt;</code> <em>TypeList</em> <code>&gt;</code></p>
<p><em>Annotation</em> :<br />
      <code>:</code> <em>Type</em></p>
<p><em>Label</em> :<br />
      <code>.</code> <a href="./lexical.html#names">ID</a></p>
</blockquote>
<h2 id="named-types"><a class="header" href="#named-types">Named Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>NamedType</em> : <a href="./lexical.html#names">ID</a> <em>TypeArguments</em><sup>?</sup></p>
</blockquote>
<p>Defined via <a href="items.html#type-definitions">type aliases</a>, named types can always be replaced with their definition without changing meaning.</p>
<pre><code class="language-par">let x: Option&lt;T&gt; = .none!
// is equivalent to
let x: either { .none!, .some T } = .none!
</code></pre>
<h2 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Unit</em> : <code>!</code></p>
</blockquote>
<p><em><sup>
<a href="types.html#the-bottom-type">Dual</a>
| <a href="./expressions/construction.html#the-unit-expression">Constructing Expression</a>
| <a href="./patterns.html#the-unit-pattern">Pattern</a>
| <a href="./statements/commands.html#the-break-command">Constructing Statement</a>
| <a href="./statements/commands.html#the-continue-command">Destructing Statement</a>
</sup></em></p>
<p>Unit is a type providing no information. In C(++) it’s called <code>void</code>, in Rust it’s <code>()</code> (and it can be thought of as an empty tuple in Par as well). There is exactly one value of type <code>!</code>, and it’s also <code>!</code>.</p>
<pre><code class="language-par">let unit: ! = !
</code></pre>
<p>Every value of a type <code>A</code> corresponds to a function <code>[!] A</code>:</p>
<pre><code class="language-par">def select: [type T] [T] [!] T = [type T] [x] [!] x
// uncurrying makes this clear
// [T] [!] T = [T, !] T ≅ [(T) !] T ≅ [T] T

def extract: [type T] [[!] T] T = [type T] [f] f(!)
</code></pre>
<p>For some types there is a function <code>[A] !</code>.
Those can be destroyed without any transformation.</p>
<pre><code class="language-par">// Types constructed only from ! are droppable
def drop_bool: [Bool] ! = [b] b {
  .true! =&gt; !
  .false! =&gt; !
}

// Functions are not droppable in general
def drop_impossible: [[Bool] Bool] ! = todo
</code></pre>
<!--// Replicables are droppable
def drop_repl: [type T] [&T] ! = !-->
<p>Mathematically, <code>!</code> is \(\mathbf{1}\), the unit for \(\otimes\).</p>
<h2 id="pair-types"><a class="header" href="#pair-types">Pair Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PairType</em> : <code>(</code> <em>TypeList</em> <code>)</code> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#function-types">Dual</a>
| <a href="./expressions/construction.html#pair-expressions">Constructing Expression</a>
| <a href="./patterns.html#pair-patterns">Pattern</a>
| <a href="./statements/commands.html#send-commands">Constructing Statement</a>
| <a href="./statements/commands.html#receive-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">type T = (A, B) R
// is equivalent to
type T = (A) (B) R
</code></pre>
<p>While <code>(A, B)!</code> and <code>(A) B</code> are both valid ways to define a pair of <code>A</code> and <code>B</code>, depending on the context, one might be more convenient than the other:</p>
<pre><code class="language-par">// convert (A, B)! into (A) B
def i : [(A, B)!] (A) B = [x]
  let (a, b)! = x in (a) b
// and back
def j : [(A) B] (A, B)! = [x]
  let (a) b = x in (a, b)!

// a good use case of (A) B
type List&lt;T&gt; = recursive either {
  .empty!
  .item(T) self
}
// can now be created like this:
let bool_list: List&lt;Bool&gt; =
  .item(.true!).item(.false!).empty!

// in most cases, (A, B)! is the safer bet
// as it uses more friendly syntax
type Pair&lt;T, T&gt; = (T, T)!

let bool_pair: Pair&lt;Bool&gt; =
  (.true!, .false!)!
</code></pre>
<p>Values are created using <a href="./expressions/construction.html#pair-expressions">pair expressions</a>:</p>
<pre><code class="language-par">let a: A = ...
let b: B = ...

let pair: (A) B = (a) b
</code></pre>
<p>and they can be destructed using <a href="">pair patterns</a> or <a href="">receive commands</a>:</p>
<pre><code class="language-par">let triple: (A, B, C)! = (a, b, c)!

// pattern matching
let (first) rest = triple
// first = a
// rest = (b, c)!

// commands
do {
  rest[second]
  // after this command:
  // rest = (c)! 
  // second = b
} in ...
</code></pre>
<p>Mathematically, <code>(A) B</code> is \(A \otimes B\). For session types, it means “send <code>A</code> and continue as <code>B</code>”.</p>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>FunctionType</em> : <code>[</code> <em>TypeList</em> <code>]</code> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#pair-types">Dual</a>
| <a href="./expressions/construction.html#function-expressions">Constructing Expression</a>
| <a href="./expressions/application.html#function-calls">Destructing Expression</a>
| <a href="./statements/commands.html#receive-commands">Constructing Statement</a>
| <a href="./statements/commands.html#send-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple types between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">type T = [A, B] R
// is equivalent to
type T = [A] [B] R
</code></pre>
<p>Values are created using <a href="./expressions/construction.html#function-expressions">function expressions</a>:</p>
<pre><code class="language-par">let add1: [Nat] Nat = [n] .succ n
</code></pre>
<p>and destructed by <a href="./expressions/application.html#function-calls">calling</a> the function:</p>
<pre><code class="language-par">let one: Nat = .succ.zero!
let two = add1(one)
</code></pre>
<p>Mathematically, <code>[A] B</code> is a <a href="./linearity.html">linear</a> function \(A \multimap B\). For session types, it means “receive <code>A</code> and continue as <code>B</code>”.</p>
<h2 id="either-types"><a class="header" href="#either-types">Either Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>EitherType</em> : <code>either</code> <code>{</code> (<em>Label</em> <em>Type</em> <code>,</code><sup>?</sup>)<sup>*</sup> <code>}</code></p>
</blockquote>
<p><em><sup>
<a href="types.html#choice-types">Dual</a>
| <a href="./expressions/construction.html#either-selections">Constructing Expression</a>
| <a href="./expressions/application.html#either-destructions">Destructing Expression</a>
| <a href="./statements/commands.html#signal-commands">Constructing Statement</a>
| <a href="./statements/commands.html#match-commands">Destructing Statement</a>
</sup></em></p>
<p>An either type is the usual sum type aka. a tagged union (in Rust, it’s an <code>enum</code>). Every value of such a type consists of a label, marking the variant, and a value of the type corresponding to the label (its “payload”).</p>
<pre><code class="language-par">// the most basic sum type
type Bool = either {
  .true!  // variant "true" with payload !
  .false! // variant "false", also with payload !
}

// a slightly more complex example
type TwoOrNone&lt;T&gt; = either {
  .none!      // variant "none" with "no" payload (using !)
  .two(T, T)! // variant "some" with "two" payloads
}
</code></pre>
<p>Values are created by attaching a label to its required payload.
Note that the corresponding either type must always be known when labeling an expression. A <a href="">type annotation</a> can be used for that.</p>
<pre><code class="language-par">let no_bool: TwoOrNone&lt;Bool&gt; = .none!

let both_bools: TwoOrNone&lt;Bool&gt; = .two(.true!, .false!)!
</code></pre>
<p>Mathematically, <code>either { .a A, .b B }</code> is \(A \oplus B\). For session types, it means “select from <code>A</code> or <code>B</code>”.
An empty either type <code>either {}</code> is therefore \(\mathbf{0}\), the empty type.
In Haskell, it’s called <code>void</code> and in Rust it’s <code>!</code> (not to be confused with the <code>!</code> in Par).
There is a function from it to every type:</p>
<pre><code class="language-par">def absurd: [type T] [either {}] T = [type T] [x] x {}
</code></pre>
<p>This function can never be called though.</p>
<p>Either types are often used as <a href="types.html#recursive-types">recursive</a> types.</p>
<h2 id="choice-types"><a class="header" href="#choice-types">Choice Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ChoiceType</em> :<br />
      <code>{</code> (<em>Label</em> (<code>(</code> <em>ReceiveTypes</em> <code>)</code>)<sup>*</sup> <code>=&gt;</code> <em>Type</em> <code>,</code><sup>?</sup>)<sup>*</sup> <code>}</code></p>
<p><em>ReceiveTypes</em> :<br />
      <em>TypeList</em> <br />
   | <code>type</code> <a href="./lexical.html#names"><em>ID_List</em></a></p>
</blockquote>
<p><em><sup>
<a href="types.html#either-types">Dual</a>
| <a href="./expressions/construction.html#choice-constructions">Constructing Expression</a>
| <a href="./expressions/application.html#choice-selections">Destructing Expression</a>
| <a href="./statements/commands.html#match-commands">Constructing Statement</a>
| <a href="./statements/commands.html#signal-commands">Destructing Statement</a>
</sup></em></p>
<p>A choice type is dual to an <a href="types.html#either-types">either</a> type. Constructing a value of an either type is “making a choice” and similarly, destructing such a value looks exactly like constructing a value of a choice type.
It consists of several labels that can be used as signals to destruct the receiver.</p>
<pre><code class="language-par">// choice of two
type BoolChoice&lt;A, B&gt; = {
  .true =&gt; A
  .false =&gt; B
}

// destruct a Bool
def negate(b: Bool): Bool = b {
  .true! =&gt; .false!
  .false! =&gt; .true!
}

// construct a choice
def negate_choice: BoolChoice&lt;Bool, Bool&gt; = {
  .true =&gt; .false!
  .false =&gt; .true!
}

// define negate using the choice
// featuring selecting from the choice type value
def also_negate: [Bool] Bool = [b] b {
  .true! =&gt; negate_choice.true
  .false! =&gt; negate_choice.false
}
</code></pre>
<p><code>.cons =&gt; [A] B</code> can also be written as <code>.cons(A) =&gt; B</code></p>
<p>A choice type represents an interface for interacting with data. While an either type describes its underlying data, a choice type describes what can be done with it.</p>
<pre><code class="language-par">// creating an interface
type Stack&lt;T, Unwrap&gt; = iterative {
  .push(T) =&gt; self
  .pop =&gt; (Option&lt;T&gt;) self
  .unwrap =&gt; Unwrap
}

// implementing it
dec list_stack : [type T] [List&lt;T&gt;] Stack&lt;T, List&lt;T&gt;&gt;
def list_stack = [type T] [list] begin {
  .push(x) =&gt; let list: List&lt;T&gt; = .item(x) list in loop
  .pop =&gt; list {
    .empty! =&gt; (.none!) let list: List&lt;T&gt; = .empty! in loop,
    .item(head) tail =&gt; (.some head) let list = tail in loop
  }
  .unwrap =&gt; list
}

def main = do {
  let stack = list_stack(type Bool)(.empty!)
  stack.push(.true!)
  stack.push(.false!)
} in stack
</code></pre>
<p>For an explanation of <code>iterative</code>-<code>self</code> and <code>begin</code>-<code>loop</code>, see <a href="types.html#iterative-types">iterative types</a></p>
<p>Mathematically, <code>{ .a =&gt; A, .b =&gt; B }</code> is \(A \mathbin{\&amp;} B\). For session types, it means “offer a choice of <code>A</code> or <code>B</code>”.
An empty choice <code>{}</code> is therefore \(\top\) and has exactly one value, <code>{}</code>. There is a function to it from every type:</p>
<pre><code class="language-par">def immortalize: [type T] [T] {} = [type T] [x] {}
</code></pre>
<p>The result of this function can never be used though.</p>
<p>Choice types are often used as <a href="types.html#iterative-types">iterative</a> types.</p>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RecursiveType</em> : <code>recursive</code> <a href="./statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#iterative-types">Dual</a>
| <a href="./expressions/application.html#recursive-destructions">Destructing Expression</a>
| <a href="./statements/commands.html#recursive-commands">Destructing Statement</a>
</sup></em></p>
<p>A recursive type can be used within itself via <code>self</code>.</p>
<p>If no loop label is present, <code>self</code> corresponds to the innermost <code>recursive</code>/<code>iterative</code>. Else to the one with the same loop label.</p>
<p>Recursive types are mostly used in conjunction with either types:</p>
<pre><code class="language-par">type List&lt;T&gt; = recursive either {
  .empty!
  .item(T) self
}
</code></pre>
<!--// another way of defining a recursive type is the following:
// Node is not recursive
type Node<Next> = either {
  .base!
  .step Next
}
// Defining the recursive type
type Rec = recursive Node<self>

// We have the following subtyping relation:
// Node<recursive Node<self>> <: recursive Node<self>-->
<p>Values of recursive types always terminate. They have to be constructed finitely.</p>
<pre><code class="language-par">// a simple List
let l: List&lt;Bool&gt; = .item(.true!).item(.false!).empty!
</code></pre>
<p>Mathematically, a recursive either type represents an inductive type.
Constructors without <code>self</code> are the base cases while those with <code>self</code> represent
inductive steps.</p>
<p>A function from a recursive type is defined using induction:</p>
<pre><code class="language-par">// recursive (inductive) type representing
// the natural numbers
type Nat = recursive either { 
  .zero!, 
  .succ self
}

dec is_even : [Nat] Bool
// induction over n (marked by applying begin-loop)
def is_even = [n] n begin {
  // base case(s)
  .zero! =&gt; .true!
  // inductive step(s)
  // pred loop is analogous to an inductive hypothesis
  .succ pred =&gt; not(pred loop)
}
</code></pre>
<h2 id="iterative-types"><a class="header" href="#iterative-types">Iterative Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IterativeType</em> : <code>iterative</code> <a href="./statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#recursive-types">Dual</a>
| <a href="./expressions/construction.html#iterative-constructions">Constructing Expression</a>
| <a href="./statements/commands.html#recursive-commands">Constructing Statement</a>
</sup></em></p>
<p>An iterative type can be used within itself via <code>self</code>.</p>
<p>If no loop label is present, <code>self</code> corresponds to the innermost <code>recursive</code>/<code>iterative</code>. Else to the one with the same loop label.</p>
<p>Iterative types are mostly used in conjunction with choice types, for example:</p>
<!--```par
type Repl<T> = iterative {
  .copy => (self, self)!
  .drop => !
  .unwrap => T
}
```-->
<pre><code class="language-par">type Stream&lt;T&gt; = iterative {
  .close =&gt; !
  .next =&gt; (T) self
}
</code></pre>
<!--Here we construct a value of an iterative type. Note the similarity
between this and destructing a recursive type.
```par
?type Bool = either { .true!, .false! }
?type Nat = recursive either { .zero!, .succ self }
?type List<T> = recursive either { .empty!, .item(T) self }
?
// construct a list of Repl<Bool>
// i.e. a value of a recursive type
//
// at the same time, destruct a value
// of the recursive type Nat
dec repeat : [Nat, Repl<Bool>] List<Bool>
def repeat = [n, b] n begin {
  .zero! => do { b.drop? } in .empty!
  .succ pred => let (b, c)! = b.copy in .item(c.unwrap) pred loop
}

// construct a value of the iterative Repl<Bool>
dec repl_bool : [Bool] Repl<Bool>
def repl_bool = [b] begin {
  .copy => b {
    .true! => (let b: Bool = .true! in loop, let b: Bool = .true! in loop)!
    .false! => (let b: Bool = .false! in loop, let b: Bool = .false! in loop)!
  }
  .drop => b {
    .true! => !
    .false! => !
  }
  .unwrap => b
}
?
?def main = repeat(.succ.succ.succ.zero!, repl_bool(.true!))
```-->
<p>Values of iterative types may be infinite. In contrast to recursive types, such values can only be <em>destructed</em> in finitely many steps.</p>
<pre><code class="language-par">type Inf&lt;T&gt; = iterative (T) self

def infinite_bools: Inf&lt;Bool&gt; = begin (.true!) loop
</code></pre>
<p>This infinite value can be constructed but there is no way of fully destructing (so: using) it.</p>
<p>Mathematically, an iterative choice type represents a coinductive type.
Destructors without <code>loop</code> break the iteration and return, while those containing <code>loop</code> yield and continue.</p>
<p>A function to an iterative type is defined using coinduction (iteration):</p>
<!--```par
// iterative (coinductive) type representing
// an infinite stream
type Stream<T> = iterative { 
  .close => !, 
  .next => (T) self
}

dec alternate_true_false : [Nat] Bool
// induction over n (marked by applying begin-loop to n)
def is_even = [n] n begin {
  // base case(s)
  .zero! => .true!
  // inductive step(s)
  .succ pred => not(pred loop)
}
```-->
<!--```par
// construct a value of the iterative Repl<Bool>
dec repl_bool : [Bool] Repl<Bool>
// coinduction (marked by an independent begin-loop)
def repl_bool = [b] begin {
  // yield "(b, b)" and
  // continue (coinductive step), written as `loop`
  .copy => b {
    .true! => (let b: Bool = .true! in loop, let b: Bool = .true! in loop)!
    .false! => (let b: Bool = .false! in loop, let b: Bool = .false! in loop)!
  }
  // break, yield !
  .drop => b {
    .true! => !
    .false! => !
  }
  // break, yield b
  .unwrap => b
}
```-->
<pre><code class="language-par"><span class="boring">type Nat = recursive either { .zero!, .succ self }
</span><span class="boring">
</span>// construct a stream of all natural numbers
// in form of the iterative Stream&lt;Nat&gt;
def nat_stream: Stream&lt;Nat&gt; = 
  let n: Nat = .zero! in 
  // coinduction (independent begin-loop)
  begin {
    // break, return !
    .close =&gt; drop(n),

    .next =&gt; do {
      let (next, n)! = copy(n)
      let n: Nat = .succ n
    } in
      // yield the next number 
      (n1)
      // continue (coinductive step)
      loop 
  }

// helpers

def drop: [Nat] ! = [n] n begin {
  .zero! =&gt; !
  .succ pred =&gt; pred loop
}

def copy: [Nat] (Nat, Nat)! = [n] n begin {
  .zero! =&gt; (.zero!, .zero!)!
  .succ pred =&gt; let (p1, p2)! = pred loop
    in (.succ p1, .succ p2)!
}
</code></pre>
<!--```par
// fibonacci sequence
def fib: Stream<Nat> = do {
  let n: Nat  = .succ.zero!
  let p: Nat = .succ.zero!
  // coinduction
} in begin {
    // break, return !
    .close => do {
      drop(n)?
      drop(p)?
    } in !

    .next => do {
      let (n1, n2)! = copy(n)
      let (p1, p2)! = copy(p)
      let p = n1
      let n = add(n2, p2)
    } in
      // yield
      (p1)
      // continue
      loop
  }
def add: [Nat, Nat] Nat = [a, b] a begin {
  .zero! => b,
  .succ pred => .succ pred loop
}
```-->
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExistentialType</em> : <code>(</code> <code>type</code> <a href="./lexical.html#names"><em>ID_List</em></a> <code>)</code> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#universal-types">Dual</a>
| <a href="./expressions/construction.html#existential-constructions">Constructing Expression</a>
| <a href="./patterns.html#existential-patterns">Pattern</a>
| <a href="./statements/commands.html#send-type-commands">Constructing Statement</a>
| <a href="./statements/commands.html#receive-type-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">type T = (type A, B) X
// is equivalent to
type T = (type A) (type B) X
</code></pre>
<p>Existential types mirror pair types but they’re qualified over types rather than values.
They are used to encapsulate their underlying type.</p>
<pre><code class="language-par"><span class="boring">type Bool  = either { .true!, .false! }
</span><span class="boring">type Nat = recursive either { .zero!, .succ self }
</span><span class="boring">
</span>type Any = (type T) T

<span class="boring">def main = chan user {
</span>// create values of the existential Any type
// note that both have exactly the same type!
let any1: Any = (type Bool) .true!
let any2: Any = (type Nat) .succ.zero!
<span class="boring">
</span><span class="boring">user(any1)
</span><span class="boring">user(any2)
</span><span class="boring">user!
</span><span class="boring">}
</span></code></pre>
<p>The qualifying types and values can both be extracted from a value of such a type:</p>
<pre><code class="language-par">let any: Any = ...
let (type X) x = any
let y: X = x
</code></pre>
<p>Mathematically, <code>(type T) A</code> is \(\exists\ T: A\).</p>
<h2 id="universal-types"><a class="header" href="#universal-types">Universal Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>UniversalType</em> : <code>[</code> <code>type</code> <a href="./lexical.html#names"><em>ID_List</em></a> <code>]</code> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#existential-types">Dual</a>
| <a href="./expressions/construction.html#universal-constructions">Constructing Expression</a>
| <a href="./expressions/application.html#universal-specializations">Destructing Expression</a>
| <a href="./statements/commands.html#receive-type-commands">Constructing Statement</a>
| <a href="./statements/commands.html#send-type-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple types between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">type T = [type A, B] X
// is equivalent to
type T = [type A] [type B] X
</code></pre>
<p>Values of universal types can be instantiated for any type. These types syntactically mirror function types but they’re qualified over types rather than values.
They’re also similar to parameterized types.</p>
<pre><code class="language-par">// compare the three types of parameterizing types
type UnivEndo = [type T] [T] T
type ParamEndo&lt;T&gt; = [T] T
type ExistEndo = (type T) [T] T

// a value of an universal type must be defined
// for all types
let id: UnivEndo = [type T] [x] x

// a specialized version can be represented using
// a parameterized type
let id_bool: ParamEndo&lt;Bool&gt; = id(type Bool)

// this type encapsulates the Bool
let id_bool_2: ExistEndo = (type Bool) id_bool
</code></pre>
<p>A more interesting example is <a href="./expressions.html#channel-expressions">reversing a list</a> of any type.</p>
<p>Mathematically, <code>[type T] A</code> is \(\forall\ T: A\).</p>
<h2 id="the-bottom-type"><a class="header" href="#the-bottom-type">The Bottom Type</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Bottom</em> : <code>?</code></p>
</blockquote>
<p><em><sup>
<a href="types.html#the-unit-type">Dual</a>
| <a href="./statements/commands.html#the-continue-command">Constructing Statement</a>
| <a href="./statements/commands.html#the-break-command">Destructing Statement</a>
</sup></em></p>
<p>The bottom <code>?</code> is dual to the unit <code>!</code>.</p>
<pre><code class="language-par">def main: Bool = chan user {
  user.true
  // user now has type ?
  user!
}
</code></pre>
<p>Mathematically, <code>?</code> is \(\bot\), the unit for \(⅋\). So \(\bot \mathbin{⅋} A = \mathbf{1} \multimap A \cong A\) (as seen before for the <a href="types.html#the-unit-type">unit</a> type).</p>
<h2 id="channel-types"><a class="header" href="#channel-types">Channel Types</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ChannelType</em> : <code>chan</code> <em>Type</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#types">Dual</a>
| <a href="expressions.html#channel-expressions">Constructing Expression</a>
</sup></em></p>
<p><code>chan A</code> represents a channel accepting an <code>A</code>:</p>
<pre><code class="language-par">def just_true: Bool = chan yield {
  let c: chan Bool = yield
  c.true!
}
</code></pre>
<p><code>chan</code> is merely a type transformer, turning a type into its dual.
For example, <code>chan chan T</code> is <em>equal</em> to <code>T</code> (not just isomorphic).</p>
<p>A more elaborate example can be seen <a href="https://github.com/faiface/par-lang/blob/main/examples/flatten.par">here</a></p>
<p>A <code>chan A</code> can be linked with an <code>A</code> (using <code>&lt;&gt;</code>), annihilating both and ending the process.</p>
<pre><code class="language-par">def just_true: Bool = chan yield {
  let c: chan Bool = yield
  let b: Bool = .true!
  c &lt;&gt; b
}
</code></pre>
<p>Note that <code>b &lt;&gt; c</code> would have been equally valid.</p>
<h2 id="duality-equations"><a class="header" href="#duality-equations">Duality equations</a></h2>
<p>Mathematically, <code>chan A</code> is \(A^\perp\), i.e. the dual type to <code>A</code>. Every type has a dual. These are defined according to this table:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Dual</th></tr></thead><tbody>
<tr><td><code>T</code></td><td><code>chan T</code></td></tr>
<tr><td><code>chan T</code></td><td><code>T</code></td></tr>
<tr><td><code>(A) B</code></td><td><code>[A] chan B</code></td></tr>
<tr><td><code>[A] B</code></td><td><code>(A) chan B</code></td></tr>
<tr><td><code>either { .a A, .b B }</code></td><td><code>{ .a =&gt; chan A, .b =&gt; chan B }</code></td></tr>
<tr><td><code>{ .a =&gt; A, .b =&gt; B }</code></td><td><code>either { .a chan A, .b chan B }</code></td></tr>
<tr><td><code>!</code></td><td><code>?</code></td></tr>
<tr><td><code>?</code></td><td><code>!</code></td></tr>
<tr><td><code>recursive T</code></td><td><code>iterative chan T</code></td></tr>
<tr><td><code>iterative T</code></td><td><code>recursive chan T</code></td></tr>
<tr><td><code>self</code></td><td><code>self</code></td></tr>
<tr><td><code>(type T) A</code></td><td><code>[type T] chan A</code></td></tr>
<tr><td><code>[type T] A</code></td><td><code>(type T) chan A</code></td></tr>
</tbody></table>
</div>
<p>Moreover, <code>chan A ≅ [A]?</code> is an isomorphism</p>
<pre><code class="language-par">dec i : [type A] [chan A] [A]?
def i = [type A] [ch] chan receive {
  // receive is of type (A)!
  receive[a]?
  ch &lt;&gt; a
}

dec j : [type A] [[A]?] chan A
def j = [type A] [annihilate] chan a {
  // a is of type A
  annihilate(a)!
}
</code></pre>
<p>So the dual of a type can be used to destruct a value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Expression</em> :<br />
      <a href="./expressions/construction.html"><em>Construction</em></a> <br />
   | <a href="./expressions/application.html"><em>Application</em></a> <br />
   | <a href="expressions.html#let-expressions"><em>LetExpression</em></a> <br />
   | <a href="expressions.html#do-expressions"><em>DoExpression</em></a> <br />
   | <a href="expressions.html#channel-expressions"><em>ChanExpression</em></a></p>
</blockquote>
<p>Every expression desugars to a <a href="expressions.html#channel-expressions">channel expression</a>. In the most simple way, that is</p>
<pre><code class="language-par">expr
// is equivalent to
chan dual {
  dual &lt;&gt; expr
}
</code></pre>
<p>This can now be further translated into process syntax by rewriting the <a href="./statements/commands.html#link-commands">link</a> <code>dual &lt;&gt; expr</code>. Rules for that are provided in every expression rule.</p>
<h2 id="primary-expressions"><a class="header" href="#primary-expressions">Primary Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PrimaryExpression</em> :<br />
      <a href="./lexical.html#names">ID</a> <br />
   | <em>GroupedExpression</em></p>
<p><em>GroupedExpression</em> :<br />
      <code>{</code> <em>Expression</em> <code>}</code></p>
</blockquote>
<p>Par uses <code>{</code> and <code>}</code> for grouping expressions together.
Together with names like <code>x</code> they form the primary expressions, which can be <a href="./expressions/application.html">destructed</a> using expressions.</p>
<p>Primary expressions appear <a href="./expressions/application.html">here</a> in the grammar.</p>
<p>Examples:</p>
<pre><code class="language-par">dec apply_id : [type T] [T] T
def apply_id = [type T] [x] {[y] y}(x)
</code></pre>
<p>Primary expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; id // can't be further simplified

dual &lt;&gt; {expr}
// is just
dual &lt;&gt; expr
</code></pre>
<h2 id="let-expressions"><a class="header" href="#let-expressions">Let Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LetExpression</em> : <code>let</code> <a href="./patterns.html"><em>Pattern</em></a> <code>=</code> <em>Expression</em> <code>in</code> <em>Expression</em></p>
</blockquote>
<p>The second expression must use all bindings of the pattern (which must be <a href="patterns.html#irrefutable-note">irrefutable</a>) due to linearity.</p>
<p>Let expressions make code easier to read by creating an expression in multiple steps. Compare:</p>
<pre><code class="language-par">let x = call_a_long_function(and_another_one(y))
in (.true!, x, .false!)!
// with
(.true!, call_a_long_function(and_another_one(y)), .false!)!
</code></pre>
<p>But arguably even morer useful are the destruction-by-pattern capabilities let expressions offer:</p>
<pre><code class="language-par">// this expression is not possible
// without let or do expressions
let (b1, b2)! = copy_bool(b)
in (b1, not(b2))!
</code></pre>
<p><a href="./statements.html#let-statements">Let statements</a> are very similar, so when multiple let expressions in a row would be required, it’s often more convenient to switch to those and put them inside <a href="expressions.html#do-expressions">do expressions</a>.</p>
<p>Let expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; let p = x in y
// is equivalent to
let p = x
dual &lt;&gt; y
</code></pre>
<h2 id="do-expressions"><a class="header" href="#do-expressions">Do Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>DoExpression</em> : <code>do</code> <code>{</code> <a href="./statements.html"><em>Process</em></a> <code>}</code> <code>in</code> <em>Expression</em></p>
</blockquote>
<p>Do expressions allow <a href="statements.html">process syntax</a> inside an expression context:</p>
<pre><code class="language-par">do { 
  commands... 
} in result
// is equivalent to
chan return {
  commands...
  return &lt;&gt; result
}
</code></pre>
<p>Linearity requires that all leftover bindings from the process must be used in the expression at the end.</p>
<p>Do expressions are useful for…</p>
<pre><code class="language-par">// ...binding multiple values with let
do {
  let v1 = e1
  ...
  let vn = en
} in result
// is preferred over
let v1 = e1 in
...
let vn = en in
result

// ...destructing values
do {
  drop(x1)?
  drop(x2)?
} in result
</code></pre>
<p>Expressions construct, commands destruct.
Because of this, when a value is destructed, process syntax (for example via a do expression) is the way to go.</p>
<p>Do expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; do { proc } in y
// is equivalent to
proc
dual &lt;&gt; y
</code></pre>
<h2 id="channel-expressions"><a class="header" href="#channel-expressions">Channel Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ChanExpression</em> : <code>chan</code> <a href="./lexical.html#names">ID</a> <a href="./types.html"><em>Annotation</em></a><sup>?</sup> <code>{</code> <a href="./statements.html"><em>Process</em></a> <code>}</code></p>
</blockquote>
<p>The name declared after the channel may be used inside the process and must be fully destructed inside or moved out of there.</p>
<p>The expression <code>chan a: A { ... }</code> has type <code>chan A</code>. Conversely, if <code>chan b { ... }</code> has type <code>B</code>, <code>b</code> has type <code>chan B</code>.</p>
<p>Note, that <code>chan A</code>, the <a href="./types.html#channel-types">channel type</a>, is not a separate type. It merely transforms the <code>A</code> to its dual, according to the <a href="./types.html#duality-equations">duality equations</a>.</p>
<p>These expressions are key to exploiting duality. The expression <code>chan c { ... }</code> spawns a process, and at the same time creates a channel, whose one end is accessible as <code>c</code> inside the process, and the other end is returned from the expression. The types of these are dual.</p>
<p>Channel expressions are the only expression which is not syntax sugar. Under the hood, all expressions are syntax sugar for channel expressions.</p>
<p>Par even has an intermediate representation in which all expressions are channel expressions.</p>
<p>A channel expression constructs a value by destructing a value of its dual. For example:</p>
<pre><code class="language-par">dec is_even : [Nat] Bool
def is_even = chan return: (Nat) chan Bool {
  // destruct return in this process

  return[n]
  // return is now of type chan Bool
  // and n is of type Nat

  // destruct n
  n begin {
    .zero! =&gt; {
      // fully destruct return
      return.true!
    }
    .succ =&gt; {
      // n is now its former predecessor
      n {
        .zero! =&gt; {
          // n was 1
          return.false!
        }
        .succ =&gt; {
          n loop
        }
      }
    }
  }
}
</code></pre>
<p>Learn more about destructing values using commands <a href="./statements/commands.html">here</a>.</p>
<p>A more elaborate example is reversing a list using the generator pattern:</p>
<pre><code class="language-par">dec reverse : [type T] [List&lt;T&gt;] List&lt;T&gt;

// We construct the reversed list by destructing its dual: `chan List&lt;T&gt;`.
def reverse = [type T] [list] chan yield {
  let yield: chan List&lt;T&gt; = list begin {
    // The list is empty, give back the generator handle.
    .empty!       =&gt; yield,
    // The list starts with an item `x`.
    .item(x) rest =&gt; do {
      // Traverse into the rest of the list first.            
      let yield = rest loop
      // After that, produce `x` on the reversed list.          
      yield.item(x)                  
    } in yield // Finally, give back the generator handle.
  }
  // At the very end, signal the end of the list.
  yield.empty!                       
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="construction-expressions"><a class="header" href="#construction-expressions">Construction Expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Construction</em> :<br />
      <a href="expressions/construction.html#the-unit-expression"><em>Unit</em></a> <br />
   | <a href="expressions/construction.html#pair-expressions"><em>PairExpression</em></a> <br />
   | <a href="expressions/construction.html#function-expressions"><em>FunctionExpression</em></a> <br />
   | <a href="expressions/construction.html#either-selections"><em>EitherSelection</em></a> <br />
   | <a href="expressions/construction.html#choice-constructions"><em>ChoiceConstruction</em></a> <br />
   | <a href="expressions/construction.html#iterative-constructions"><em>IterativeConstruction</em></a> <br />
   | <a href="expressions/construction.html#iterative-constructions"><em>Loop</em></a> <br />
   | <a href="expressions/construction.html#existential-constructions"><em>ExistentialConstruction</em></a> <br />
   | <a href="expressions/construction.html#universal-constructions"><em>UniversalConstruction</em></a></p>
</blockquote>
<h2 id="the-unit-expression"><a class="header" href="#the-unit-expression">The Unit Expression</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Unit</em> : <code>!</code></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#the-unit-type">Type</a>
| <a href="expressions/../patterns.html#the-unit-pattern">Pattern</a>
| <a href="expressions/../statements/commands.html#the-break-command">Statement</a>
| <a href="expressions/../statements/commands.html#the-continue-command">Destructing Statement</a>
</sup></em></p>
<p>The unit expression <code>!</code> is of the <a href="expressions/../types.html#the-unit-type">unit type</a> <code>!</code>.</p>
<p>It’s the only value of its type:</p>
<pre><code class="language-par">def unit: ! = !
</code></pre>
<p>Unit expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; !
// is equivalent to
dual!
</code></pre>
<h2 id="pair-expressions"><a class="header" href="#pair-expressions">Pair Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PairExpression</em> : <code>(</code> <a href="expressions/../expressions.html"><em>ExpressionList</em></a> <code>)</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#pair-types">Type</a>
| <a href="expressions/../patterns.html#pair-patterns">Pattern</a>
| <a href="expressions/../statements/commands.html#send-commands">Statement</a>
| <a href="expressions/../statements/commands.html#receive-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple expressions between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">(a, b) c
// is equivalent to
(a) (b) c
</code></pre>
<p>If <code>a</code> is of type <code>A</code> and <code>b</code> is of type <code>B</code>, the pair expression <code>(a) b</code> is of the <a href="expressions/../types.html#pair-types">pair type</a> <code>(A) B</code>.</p>
<pre><code class="language-par">let bool_pair: (Bool, Bool)! = (.true!, .false!)!
</code></pre>
<p>The difference between representing a pair of <code>A</code> and <code>B</code> as <code>(A, B)!</code> or <code>(A) B</code> is:</p>
<ul>
<li>
<p><code>(A1, ..., An)!</code>. is the default for regular tuples.</p>
<pre><code class="language-par">let zero_to_two: (Nat, Nat, Nat)! = (
  .zero!,
  .succ.zero!,
  .succ.succ.zero!,
)!
</code></pre>
</li>
<li>
<p><code>(A1, ..., An) B</code> more specifically means “send <code>A1</code>, …, and <code>An</code>, then continue as <code>B</code>”. It’s used when all but the last member of a tuple should be received separately and the receiver should continue as the last one. For example:</p>
<pre><code class="language-par">def length: [List] (Nat) List = [l] l begin {
  .empty! =&gt; (.zero!) .empty!,
  .item(head) tail =&gt; do {
    // tail loop is of type (Nat) List
    tail loop
    // receive len_pred 
    tail[len_pred]
    // tail is now as before
  } in (.succ len_pred) .item(head) tail
}
</code></pre>
</li>
</ul>
<p>Pair expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; (a) b
// is equivalent to
dual(a)
dual &lt;&gt; b
</code></pre>
<h2 id="function-expressions"><a class="header" href="#function-expressions">Function Expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>FunctionExpression</em> : <code>[</code> <a href="expressions/../patterns.html"><em>PatternList</em></a> <code>]</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#function-types">Type</a>
| <a href="expressions/application.html#function-calls">Destructing Expression</a>
| <a href="expressions/../statements/commands.html#receive-commands">Statement</a>
| <a href="expressions/../statements/commands.html#send-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple patterns between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">[p, q] x
// is equivalent to
[p] [q] x
</code></pre>
<p>If <code>p</code> is an <a href="expressions/patterns.html#irrefutable-note">irrefutable</a> pattern for type <code>A</code> and <code>b</code> (wich must use the bindings of <code>p</code>) is of type <code>B</code>, the function expression <code>[p] b</code> is of the <a href="expressions/../types.html#function-types">function type</a> <code>[A] B</code>.</p>
<p>We’ve already seen a lot of functions, so here’s a simple one:</p>
<pre><code class="language-par">def add2: [Nat] Nat = [n] .succ.succ n
</code></pre>
<p>Note that function expressions are the primary way of defining functions in par. Defining a function looks the same as defining any other value.</p>
<p>Function expressions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; [p] b
// is equivalent to
dual[p]
dual &lt;&gt; b
</code></pre>
<h2 id="either-selections"><a class="header" href="#either-selections">Either Selections</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>EitherSelection</em> : <a href="expressions/../types.html"><em>Label</em></a> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#either-types">Type</a>
| <a href="expressions/application.html#either-destructions">Destructing Expression</a>
| <a href="expressions/../statements/commands.html#signal-commands">Statement</a>
| <a href="expressions/../statements/commands.html#match-commands">Destructing Statement</a>
</sup></em></p>
<p>The type of an either selection cannot be inferred from itself. <br />
A selection of the <a href="expressions/../types.html#either-types">either type</a> <code>either { .a A, .b B }</code> is either <code>.a a</code> if <code>a</code> is of type <code>A</code> or <code>.b b</code> if <code>b</code> is of type <code>B</code>.</p>
<pre><code class="language-par">type Bool = either {
  .true!,
  .false!,
}

def true: Bool = .true!
</code></pre>
<p><a href="expressions/../types.html#recursive-types">Recursive types</a> have no special construction syntax, instead they are finitely constructed as their underlying type. Most often they’re seen as <code>recursive either</code> types:</p>
<pre><code class="language-par">type Nat = recursive either {
  .zero!,
  .succ self,
}

// construct a value of the recursive
// Nat type like any other either type
def two = .succ.succ.zero!
</code></pre>
<p>Either selections can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; .a a
// is equivalent to
dual.a
dual &lt;&gt; a
</code></pre>
<h2 id="choice-constructions"><a class="header" href="#choice-constructions">Choice Constructions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ChoiceConstruction</em> :<br />
      <code>{</code> (<a href="expressions/../types.html"><em>Label</em></a> (<code>(</code> <em>ReceivePatterns</em> <code>)</code>)<sup>*</sup> <code>=&gt;</code> <em>Expression</em> <code>,</code><sup>?</sup>)<sup>*</sup> <code>}</code></p>
<p><em>ReceivePatterns</em> :<br />
      <em>PatternList</em> <br />
   | <code>type</code> <a href="expressions/../lexical.html#names"><em>ID_List</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#choice-types">Type</a>
| <a href="expressions/application.html#choice-selections">Destructing Expression</a>
| <a href="expressions/../statements/commands.html#match-commands">Statement</a>
| <a href="expressions/../statements/commands.html#signal-commands">Destructing Statement</a>
</sup></em></p>
<p>If <code>a</code> is of type <code>A</code> and <code>b</code> is of type <code>B</code>, the choice construction <code>{ .a =&gt; a, .b =&gt; b }</code> is of the <a href="expressions/../types.html#choice-types">choice type</a> <code>{ .a =&gt; A, .b =&gt; B }</code>.</p>
<p>Some patterns can be used on the left side:</p>
<ul>
<li><code>{ .a(p) =&gt; a }</code> is equivalent to <code>{ .a =&gt; [p] a }</code></li>
<li><code>{ .a(type T) =&gt; a }</code> is equivalent to <code>{ .a =&gt; [type T] a }</code></li>
</ul>
<p>Choice constructions look very similar to <a href="expressions/application.html#match-expressions">match expressions</a> (intentionally!).</p>
<pre><code class="language-par">type BoolChoice = {
  .true =&gt; Bool,
  .false =&gt; Bool,
}

def negate: BoolChoice = {
  .true =&gt; .false!,
  .false =&gt; .true!,
}
</code></pre>
<p>Choice constructions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; { .a =&gt; a, .b =&gt; b }
// is equivalent to
dual { 
  .a =&gt; { dual &lt;&gt; a }
  .b =&gt; { dual &lt;&gt; b }
}
</code></pre>
<h2 id="iterative-constructions"><a class="header" href="#iterative-constructions">Iterative Constructions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IterativeConstruction</em> :<br />
      <code>begin</code> <a href="expressions/../statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>Loop</em> :<br />
      <code>loop</code> <a href="expressions/../statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#iterative-types">Type</a>
| <a href="expressions/../statements/commands.html#recursive-commands">Statement</a>
</sup></em></p>
<p>If — given every <code>loop</code> in <code>a</code> is of type <code>iterative A</code> — <code>a</code> is of type <code>A</code>, the iterative construction <code>begin a</code> is of the <a href="expressions/../types.html#iterative-types">iterative type</a> <code>iterative A</code>.</p>
<p>A <code>loop</code> corresponds to the innermost <code>begin</code> with the same loop label. <code>loop</code> without a label can only correspond to <code>begin</code> without a label.</p>
<p>Iterative types are constructed with <code>begin</code>-<code>loop</code> and as such, their values are often infinite. This is not a problem, however, as they don’t have special syntax for destruction, i.e. they can only be finitely destructed.</p>
<pre><code class="language-par">type Omega = iterative {
  .close =&gt; !,
  .next =&gt; self,
}

// This value is infinite:
// .next can be called as often
// as one desires
// (but only finitely many times)
def omega: Omega = begin {
  .close =&gt; !,
  .next =&gt; loop,
}
</code></pre>
<p>Iterative constructions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; begin a
// is equivalent to
dual begin
dual &lt;&gt; a // with loop in a replaced by begin a
</code></pre>
<h2 id="existential-constructions"><a class="header" href="#existential-constructions">Existential Constructions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExistentialConstruction</em> : <code>(</code> <code>type</code> <a href="expressions/../types.html"><em>TypeList</em></a> <code>)</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#existential-types">Type</a>
| <a href="expressions/../patterns.html#existential-patterns">Pattern</a>
| <a href="expressions/../statements/commands.html#send-type-commands">Statement</a>
| <a href="expressions/../statements/commands.html#receive-type-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">(type A, B) c
// is equivalent to
(type A) (type B) c
</code></pre>
<p>If <code>a</code> is of type <code>A</code>, the existential construction <code>(type T) a</code> is of the <a href="expressions/../types.html#existential-types">existential type</a> <code>(type T) A</code>.</p>
<pre><code class="language-par">type Any = (type T) T

let any_bool: Any = (type Bool) .true!
let any_unit: Any = (type !) !
</code></pre>
<p>Existential constructions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; (type T) a
// is equivalent to
dual(type T)
dual &lt;&gt; a
</code></pre>
<h2 id="universal-constructions"><a class="header" href="#universal-constructions">Universal Constructions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>UniversalConstruction</em> : <code>[</code> <code>type</code> <a href="expressions/../lexical.html#names"><em>ID_List</em></a> <code>]</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#universal-types">Type</a>
| <a href="expressions/application.html#universal-specializations">Destructing Expression</a>
| <a href="expressions/../statements/commands.html#receive-type-commands">Statement</a>
| <a href="expressions/../statements/commands.html#send-type-commands">Destructing Statement</a>
</sup></em></p>
<p>Having multiple names between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">[type T, U] x
// is equivalent to
[type T] [type U] x
</code></pre>
<p>If <code>a</code> is of type <code>A</code>, the universal construction <code>[type T] a</code> (where <code>a</code> can use the type <code>T</code>) is of the <a href="expressions/../types.html#universal-types">universal type</a> <code>[type T] A</code>.</p>
<p>Universal constructions are moslty used to define “generic functions”:</p>
<pre><code class="language-par">def empty_list : [type T] List&lt;T&gt; = [type T] .empty!

// called via
let bools: List&lt;Bool&gt; = empty_list(type Bool)
</code></pre>
<p>Universal constructions can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; [type T] a
// is equivalent to
dual[type T]
dual &lt;&gt; a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-expressions"><a class="header" href="#application-expressions">Application Expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Application</em> :<br />
      <em>Applicable</em> <br />
   | <a href="expressions/application.html#match-expressions"><em>MatchExpression</em></a> <br />
   | <a href="expressions/application.html#recursive-destructions"><em>LoopApplication</em></a></p>
<p><em>Applicable</em> :<br />
      <a href="expressions/../expressions.html#primary-expressions"><em>PrimaryExpression</em></a> <br />
   | <a href="expressions/application.html#function-calls"><em>FunctionCall</em></a> <br />
   | <a href="expressions/application.html#choice-selections"><em>ChoiceSelection</em></a> <br />
   | <a href="expressions/application.html#recursive-destructions"><em>RecursiveDestruction</em></a> <br />
   | <a href="expressions/application.html#universal-specializations"><em>UniversalSpecialization</em></a></p>
</blockquote>
<p>While <a href="expressions/construction.html">constructions</a> construct values, applications destruct them. Some types do not have an application expression for destruction – they use <a href="expressions/../patterns.html">patterns</a> instead.</p>
<p>An application is always of the form: <em>Applicable</em> <em>Suffix</em>.
Every application corresponds to a <a href="expressions/../statements/commands.html">command</a>, which looks the same. In contrast to commmand receivers however, applicables don’t become the result of this expression.</p>
<p>All applications can be linked via:</p>
<pre><code class="language-par">dual &lt;&gt; app suffix
// is equivalent to
let a = app
a suffix
dual &lt;&gt; a
</code></pre>
<p>Note that if app is a local variable, the <code>let</code> is not needed.</p>
<h2 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>FunctionCall</em> : <em>Applicable</em> <code>(</code> <a href="expressions/../expressions.html"><em>ExpressionList</em></a> <code>)</code></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#function-types">Destructs Type</a>
| <a href="expressions/construction.html#function-expressions">Destructs Expression</a>
| <a href="expressions/../statements/commands.html#send-commands">Statement</a>
</sup></em></p>
<p>Having multiple expressions between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">f(a, b)
// is equivalent to
f(a)(b)
</code></pre>
<p>If <code>f</code> is of type <code>[A] B</code> and <code>a</code> is of type <code>A</code>, the function call <code>f(a)</code> is of type <code>B</code>.</p>
<pre><code class="language-par">def function: [A] B

let a: A = ...
let b: B = function(a)
</code></pre>
<p>A function call is equivalent to a <a href="expressions/../statements/commands.html#send-commands">send command</a>:</p>
<pre><code class="language-par">// in process syntax
let b = f(a)
// is equivalent to
let b = f
b(a)
</code></pre>
<h2 id="choice-selections"><a class="header" href="#choice-selections">Choice Selections</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ChoiceSelection</em> : <em>Applicable</em> <a href="expressions/../types.html"><em>Label</em></a></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#choice-types">Destructs Type</a>
| <a href="expressions/construction.html#choice-constructions">Destructs Expression</a>
| <a href="expressions/../statements/commands.html#signal-commands">Statement</a>
</sup></em></p>
<p>If <code>x</code> is of type <code>{ ..., .label =&gt; T, ... }</code>, the choice selection <code>x.label</code> is of type <code>T</code>.</p>
<pre><code class="language-par">type BoolChoice = {
  .true =&gt; Bool,
  .false =&gt; Bool,
}

let bc: BoolChoice = ...
let choose_true = bc.true
</code></pre>
<p><a href="expressions/../types.html#iterative-types">Iterative types</a> have no special destruction syntax, instead they are finitely destructed as their underlying type. Most often they’re seen as iterative choice types:</p>
<pre><code class="language-par">type Stream&lt;T&gt; = iterative {
  .close =&gt; !,
  .next =&gt; (T) self
}

let nats: Stream&lt;Nat&gt; = ...

// finitely destruct nats
do {
  let (first) rest = nats.next
  let (second) rest = nats.next
  let ! = rest.close
} in (first, second)!
</code></pre>
<p>A choice selection is equivalent to a <a href="expressions/../statements/commands.html#signal-commands">signal command</a>:</p>
<pre><code class="language-par">// in process syntax
let y = x.label
// is equivalent to
let y = x
y.label
</code></pre>
<h2 id="match-expressions"><a class="header" href="#match-expressions">Match Expressions</a></h2>
<!--
> **<sup>Syntax</sup>**\
> _MatchExpression_ : _Applicable_ `{` (_Pattern_ `=>` _Expression_ `,`<sup>?</sup>)<sup>\*</sup> `}`
-->
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MatchExpression</em> : <em>Applicable</em> <code>{</code> (<a href="expressions/../types.html"><em>Label</em></a> (<code>(</code> <a href="expressions/construction.html#choice-constructions"><em>ReceivePatterns</em></a> <code>)</code>)<sup>*</sup> (<a href="expressions/../lexical.html#names">ID</a> | <code>!</code>) <code>=&gt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a> <code>,</code><sup>?</sup>)<sup>*</sup> <code>}</code></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#either-types">Destructs Type</a>
| <a href="expressions/construction.html#either-selections">Destructs Expression</a>
| <a href="expressions/../statements/commands.html#match-commands">Statement</a>
</sup></em></p>
<p>Match expressions are similar to <code>match</code> in Rust or <code>case</code> in Haskell. Their pattern matching abilities are currently limited but will expand in the <a href="expressions/../future.html">future</a>.</p>
<p>If <code>x</code> is of type <code>either { .l1 T1, ..., .ln Tn }</code>
and</p>
<ul>
<li><code>p1</code> is a <a href="expressions/../patterns.html">pattern</a> for type <code>T1</code>, and so on, until <code>pn</code> is a pattern for type <code>Tn</code></li>
<li><code>y1</code>, …, <code>yn</code> are all of type <code>U</code></li>
</ul>
<p>then <code>x { .l1 p1 =&gt; y1, ..., .ln pn =&gt; yn }</code> is of type <code>U</code>. It evaluates to the <code>yi</code> which label <code>.li</code> was matched.</p>
<pre><code class="language-par">type Option&lt;T&gt; = either {
  .none!,
  .some T
}

let o: Option&lt;Nat&gt; = ...

let o_add1: Option&lt;Nat&gt; = o {
  .none! =&gt; .none!,
  .some n =&gt; .some.succ n,
}
</code></pre>
<h2 id="recursive-destructions"><a class="header" href="#recursive-destructions">Recursive Destructions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RecursiveDestruction</em> :<br />
      <em>Applicable</em> <code>unfounded</code><sup>?</sup> <code>begin</code> <a href="expressions/../statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup></p>
<p><em>LoopApplication</em> :<br />
      <em>Applicable</em> <code>loop</code> <a href="expressions/../statements/commands.html#recursive-commands"><em>LoopLabel</em></a><sup>?</sup></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#recursive-types">Destructs Type</a>
| <a href="expressions/../statements/commands.html#recursive-commands">Statement</a>
</sup></em></p>
<p>A <code>loop</code> corresponds to the innermost <code>begin</code> with the same loop label. <code>loop</code> without a label can only correspond to <code>begin</code> without a label.</p>
<p>If <code>x</code> is of type <code>recursive T</code>, then <code>begin x</code> is of type <code>T</code>, replacing each corresponding <code>self</code> of <code>T</code> with <code>recursive T</code>.</p>
<p>A <code>loop</code> corresponding to this <code>begin</code> can be used on values of type <code>recursive T</code>. Its behavior is equivalent to “pasting” the <code>begin</code> and every application that follows it.</p>
<div class="warning">
<p>Due to totality, <code>loop</code> can only be called on a descendant of the value <code>begin</code> was called on. I.e. on a value which type is a “<code>self</code>” correponding to the recursive type which <code>begin</code> was called on.</p>
<p>If that is not the case, the unsafe <code>unfounded begin</code> must be used, which leaves it up to the programmer to ensure totality.</p>
</div>
<p>Consider the recursive type</p>
<pre><code class="language-par">type List&lt;T&gt; = recursive either {
  .empty!,
  .item(T) self,
}
</code></pre>
<p>This is a total <code>begin</code>-<code>loop</code></p>
<pre><code class="language-par">dec reverse : [type T] [List&lt;T&gt;] List&lt;T&gt;
def reverse = [type T] [list] do {
  let rev = .empty!
} in list begin {
  .empty! =&gt; rev,
  .item(head) tail =&gt; do {
    let rev = .item(head) rev
  } in tail loop
  // tail corresponds to the self in the
  // .item(T) self
  // branch
}
</code></pre>
<p>This is a total <code>unfounded begin</code>-<code>loop</code>, as the totality checker currently doesn’t recognize this loop as total.</p>
<pre><code class="language-par">dec reverse : [type T] [List&lt;T&gt;] List&lt;T&gt;
def reverse = [type T] [list] list unfounded begin {
  .empty! =&gt; .empty!,
  .item(head) tail =&gt; do {
    let (left, right)! = split(type T)(.item(head) tail)
  } in concat(type T)(
    left loop,
    right loop,
  )
}

/// splits the list into two lists
/// of equal length
/// (the left list may be one longer)
dec split : [type T] [List&lt;T&gt;] (List&lt;T&gt;, List&lt;T&gt;)!

/// concatenates two lists
dec concat : [type T] [List&lt;T&gt;, List&lt;T&gt;] List&lt;T&gt;
</code></pre>
<p>This is a nontotal <code>unfounded begin</code>-<code>loop</code>. Caution is required when using these to not lose totality.</p>
<pre><code class="language-par">def infinite_loop: ! = do {
  let list: List&lt;!&gt; = .item(!).empty!
} in list unfounded begin {
  .empty! =&gt; !, // this is total
  .item(head) tail =&gt; do {
    let list: List&lt;!&gt; = .item(head) tail
  } in list loop, // this is not total
}
</code></pre>
<h2 id="universal-specializations"><a class="header" href="#universal-specializations">Universal Specializations</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>UniversalSpecialization</em> : <em>Applicable</em> <code>(</code> <code>type</code> <a href="expressions/../types.html"><em>TypeList</em></a> <code>)</code></p>
</blockquote>
<p><em><sup>
<a href="expressions/../types.html#universal-types">Destructs Type</a>
| <a href="expressions/construction.html#universal-constructions">Destructs Expression</a>
| <a href="expressions/../statements/commands.html#receive-type-commands">Statement</a>
</sup></em></p>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">x(type T, U)
// is equivalent to
x(type T)(type U)
</code></pre>
<p>If <code>x</code> is of the universal type <code>[type T] R</code>, the specialization <code>f(type X)</code> is of type <code>R</code>.</p>
<p>These expressions often “instantiate generic functions”</p>
<pre><code class="language-par">def id = [type T] [x: T] x

def id_bool: [Bool] Bool = id(type Bool)
def id_unit: [!] ! = id(type !)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Pattern</em> :<br />
      <em>PatternNoAlt</em> <!--\
> &nbsp;&nbsp; | [_AltPattern_](#alternatives)--></p>
<p><em>PatternNoAlt</em> :<br />
      <a href="patterns.html#binding-patterns"><em>BindingPattern</em></a> <br />
   | <a href="patterns.html#the-unit-pattern"><em>Unit</em></a> <br />
   | <a href="patterns.html#pair-patterns"><em>PairPattern</em></a> <!--\
> &nbsp;&nbsp; | [_VariantPattern_](#variant-patterns) \
> &nbsp;&nbsp; | [_BlankPattern_](#the-blank-pattern) \
> &nbsp;&nbsp; | [_GroupedPattern_](#grouped-patterns) --><br />
   | <a href="patterns.html#existential-patterns"><em>ExistentialPattern</em></a></p>
<p><em>PatternList</em> :<br />
      <em>PatternNoAlt</em> (<code>,</code> <em>PatternNoAlt</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>There are two properties of a pattern: What names it <em>binds</em> and whether it’s <em>refutable</em>.</p>
<div id="irrefutable-note" class="warning" style="--warning-border: var(--note-border)">
<p>Currently, all patterns are irrefutable. Because of plans to extend the patterns system (see the <a href="patterns.html#future">Future</a> section) this word (irrefutable) is used throughout this part of the reference. It can be safely ignored for now.</p>
</div>
<p>Patterns can appear in several places:</p>
<ul>
<li>
<p>in a <code>let</code> binding:</p>
<pre><code class="language-par">// as an expression
let p = x in y

// or in process syntax
let p = x
rest...
</code></pre>
<p>All bindings of <code>p</code> must be used in <code>y</code> or <code>rest...</code> respectively.
Here, <code>p</code> must be irrefutable.</p>
</li>
<li>
<p>between <code>[</code> and <code>]</code></p>
<pre><code class="language-par">// in a function expression
[p] body

// destructing a pair (process syntax)
tail[p]
rest...
</code></pre>
<p>All bindings of <code>p</code> must be used in <code>body</code> or <code>rest...</code> respectively.
Here, <code>p</code> must also be irrefutable.</p>
</li>
</ul>
<!-- - in pattern matching, i.e. either destruction
  ```par
  x {
    p1 => y1,
    p2 => y2,
    ...
  }
  ```
  Here, the patterns `p1`, `p2`, ... don't have to be irrefutable. All bindings of a pattern `p` must be used in the corresponding branch `y` though.

  The matching must be *exhaustive*, i.e. every possible value of `x` must be matched in some branch. If multiple branches would match `x`, the first one is used.-->
<ul>
<li>in pattern matching, i.e. either destruction/choice construction
<pre><code class="language-par">// either destruction
x {
  .label (p) rest_payload =&gt; y
  ...
}
// in process syntax, the rest_payload isn't present
// (instead, x becomes it)

// choice construction
{
  .label (p) =&gt; y
  ...
}
</code></pre>
All bindings of <code>p</code> must be used in <code>y</code>.
Here, <code>p</code> must also be irrefutable.</li>
</ul>
<h2 id="binding-patterns"><a class="header" href="#binding-patterns">Binding Patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BindingPattern</em> : <a href="./lexical.html#names">ID</a> <a href="./types.html"><em>Annotation</em></a><sup>?</sup> <!--(`@` _PatternNoAlt_)<sup>?</sup>--></p>
</blockquote>
<!--The optional `@` and what comes after is called a *subpattern*.

If no subpattern is present, the pattern always matches and binds to its name:-->
<p>The pattern <code>name</code> or <code>name: T</code> is always irrefutable and binds <code>name</code> to <code>x</code> when matching <code>x</code>.</p>
<p>The pattern <code>name</code> can be used on a value which type is known. Otherwise, <code>name: T</code> must be used, which can only be used on a value of type <code>T</code>.</p>
<p>Binding patterns are the most used patterns.</p>
<pre><code class="language-par">// break up an expression
do {
  let v1 = e1
  let v2 = e2
} in // expression using v1 and v2
</code></pre>
<p>If the type of the value matched is already known, a type annotation would have to match it.
Such an annotation can be useful for declaring functions, though:</p>
<pre><code class="language-par">// no extra type annotation/declaration needed
def negate = [b: Bool] let result: Bool = b {
  .true! =&gt; .false!
  .false! =&gt; .true!
} in result
</code></pre>
<!--If a subpattern is present, however, `name @ subp` matches exactly when `subp` matches. Generally, it is refutable. When matching `x`, it binds `name` to `x`. All bindings of `subp` are consumed by `name`, i.e. they can't be used anymore. For that reason, the [blank pattern](#the-blank-pattern) `_` may be used inside `subp`.
```par
// example
```-->
<h2 id="the-unit-pattern"><a class="header" href="#the-unit-pattern">The Unit Pattern</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Unit</em> : <code>!</code></p>
</blockquote>
<p><em><sup>
<a href="types.html#the-unit-type">Type</a>
| <a href="./expressions/construction.html#the-unit-expression">Constructing Expression</a>
| <a href="./statements/commands.html#the-continue-command">Destructing Statement</a>
</sup></em></p>
<p>The unit pattern <code>!</code> is always irrefutable and binds nothing.
It can only be used on values of type <code>!</code>.</p>
<pre><code class="language-par">// if there is a value of a type T,
// there is a function [!] T
def returns_true: [!] Bool = [!] .true!

// ! can be used to destroy a unit
def drop_two_bools: [Bool, Bool] ! = 
  [b1, b2] let ! = drop(b1) in drop(b2)

// though process syntax is generally used for this
def drop_two_bools: [Bool, Bool] ! = [b1, b2] do {
  drop(b1)?
  drop(b2)?
} in !

dec drop_bool : [Bool] ! 
<span class="boring">def drop_bool = [b] {
</span><span class="boring">  .true! =&gt; !
</span><span class="boring">  .false! =&gt; !
</span><span class="boring">}
</span></code></pre>
<h2 id="pair-patterns"><a class="header" href="#pair-patterns">Pair Patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PairPattern</em> : <code>(</code> <em>PatternList</em> <code>)</code> <em>Pattern</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#pair-types">Type</a>
| <a href="./expressions/construction.html#pair-expressions">Constructing Expression</a>
| <a href="./statements/commands.html#receive-commands">Destructing Statement</a>
</sup></em></p>
<ul>
<li>A pair pattern <code>(p) q</code> is irrefutable if and only if both <code>p</code> and <code>q</code> are irrefutable</li>
<li>When <code>p</code> can be used on type <code>A</code> and <code>q</code> on type <code>B</code>, <code>(p) q</code> can be used on type <code>(A) B</code></li>
<li><code>(p) q</code> matches <code>(a) b</code> if and only if <code>p</code> matches <code>a</code> and <code>q</code> matches <code>b</code></li>
<li>When matching <code>(a) b</code>, the bindings are those of <code>p</code> matching <code>a</code>, together with those of <code>q</code> matching <code>b</code></li>
</ul>
<p>Having multiple patterns between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">// the pattern
(p, q) r
// is equivalent to
(p) (q) r
</code></pre>
<p>A pair pattern is used to destruct a value of a <a href="types.html#pair-types">pair type</a>:</p>
<pre><code class="language-par">dec uncurry : [type A, B, C] [[A, B] C] [(A, B)!] C
def uncurry = [type A, B, C] [f] [(a, b)!] f(a, b)
</code></pre>
<h2 id="existential-patterns"><a class="header" href="#existential-patterns">Existential Patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExistentialPattern</em> : <code>(</code> <code>type</code> <a href="./lexical.html#names">ID</a> <code>)</code> <em>Pattern</em></p>
</blockquote>
<p><em><sup>
<a href="types.html#existential-types">Type</a>
| <a href="./expressions/construction.html#existential-constructions">Constructing Expression</a>
| <a href="./statements/commands.html#receive-type-commands">Destructing Statement</a>
</sup></em></p>
<ul>
<li>An existential pattern <code>(type X) p</code> can only be used on an existential type <code>(type T) A</code> and <code>p</code> must be able to be used on type <code>A</code></li>
<li>When it can match, it is irrefutable if and only if <code>p</code> is irrefutable</li>
<li><code>(type X) p</code> matches <code>(type T) a</code> if and only if <code>p</code> matches <code>a</code></li>
<li>When matching <code>(type T) a</code>, the bindings are those of <code>p</code> matching <code>a</code>, and <code>X</code> is bound to <code>T</code></li>
</ul>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">// the pattern
(type X, Y) p
// is equivalent to
(type X) (type Y) p
</code></pre>
<p>An existential pattern is used to destruct a value of an <a href="types.html#existential-types">existential type</a></p>
<pre><code class="language-par">type Any = (type T) T

def any_test: Any = do {
  let x: Any = (type Bool) .true!
  let (type X) x_val = x
  // X = Bool
  // x_val = .true!
  let y: X = x_val
} (type X) y
</code></pre>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<p>More extensive pattern matching, along with more types of patterns is planned in the future. See <a href="future.html">here</a> for more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<p>Statements are used in <strong>process syntax</strong> to</p>
<ul>
<li>destruct values: <a href="./statements/commands.html"><em>Command</em></a></li>
<li>bind values: <a href="statements.html#let-statements"><em>LetStatement</em></a></li>
</ul>
<p>Process syntax is a series of statements, where all are nonterminating. In a <code>channel</code> expression the last one will be terminating, making it an exception.</p>
<p>Process syntax is introduced by the <em>Proces</em> Rule:</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Process</em> : (<em>Statement</em> (<code>;</code><sup>?</sup> <em>Statement</em>) (<code>;</code><sup>?</sup> <em>TerminatingStatement</em>)<sup>?</sup>)<sup>?</sup></p>
<p><em>Statement</em> :<br />
      <a href="./statements/commands.html"><em>Command</em></a> <br />
   | <a href="statements.html#let-statements"><em>LetStatement</em></a></p>
<p><em>TerminatingStatement</em> :<br />
      <a href="./statements/commands.html"><em>TerminatingCommand</em></a></p>
</blockquote>
<p>It is used in the following places:</p>
<ul>
<li>
<p><a href="./expressions.html#do-expressions">do expressions</a>:</p>
<pre><code class="language-par">let x = do { process } in value
</code></pre>
<p>The process here may not use terminating statements.</p>
</li>
<li>
<p><a href="expressions.html#channel-expressions">channel expressions</a>:</p>
<pre><code class="language-par">let x = chan dual { process }
</code></pre>
<p>The process here must use a terminating statement. It constructs <code>x</code> by destructing its dual, <code>dual</code>.</p>
</li>
</ul>
<h2 id="let-statements"><a class="header" href="#let-statements">Let Statements</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LetStatement</em> :<br />
      <code>let</code> <a href="patterns.html"><em>Pattern</em></a> <code>=</code> <a href="expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>Let statements are used to create values in processes. They are the only constructive statements, as commands always destruct.</p>
<p>In <code>do</code> expressions, they are used to bind the values used in the value after <code>in</code>:</p>
<pre><code class="language-par">let true_and_false = do {
  let x: Bool = .true!
  let y: Bool = .false!
} in (x, y)!
</code></pre>
<p>In <code>chan</code> expressions, they can be used to construct a value that is then linked with a value of dual type:</p>
<pre><code class="language-par">def just_true = chan return: chan Bool {
  // constructing the return value
  let b: Bool = .true!
  // linking it
  return &lt;&gt; b
}
// is equivalent to
def just_true = chan return: chan Bool {
  // destructing the result
  return.true!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Command</em> :<br />
      <a href="statements/commands.html#the-continue-command"><em>ContinueCommand</em></a> <br />
   | <a href="statements/commands.html#send-commands"><em>SendCommand</em></a> <br />
   | <a href="statements/commands.html#receive-commands"><em>ReceiveCommand</em></a> <br />
   | <a href="statements/commands.html#signal-commands"><em>SignalCommand</em></a> <br />
   | <a href="statements/commands.html#match-commands"><em>MatchCommand</em></a> <br />
   | <a href="statements/commands.html#recursive-commands"><em>BeginCommand</em></a> <br />
   | <a href="statements/commands.html#send-type-commands"><em>SendTypeCommand</em></a> <br />
   | <a href="statements/commands.html#receive-type-commands"><em>ReceiveTypeCommand</em></a></p>
<p><em>TerminatingCommand</em> :<br />
      <a href="statements/commands.html#the-break-command"><em>BreakCommand</em></a> <br />
   | <a href="statements/commands.html#link-commands"><em>LinkCommand</em></a> <br />
   | <a href="statements/commands.html#recursive-commands"><em>Loop</em></a></p>
<p><em>Receiver</em> :<br />
      <a href="statements/../lexical.html#names">ID</a> <br />
   | <em>Command</em></p>
</blockquote>
<p>Nonterminating commands can be chained.</p>
<pre><code class="language-par">rec cmd1 cmd2
// is just
rec cmd1
rec cmd2
</code></pre>
<h2 id="link-commands"><a class="header" href="#link-commands">Link Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LinkCommand</em> : <em>Receiver</em> <code>&lt;&gt;</code> <a href="statements/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>Link commands are symmetric, i.e. <code>a &lt;&gt; b</code> is the same as <code>b &lt;&gt; a</code>. On the right side, any expression can be used, however.</p>
<p>The types on both sides must be dual to each other.
The link then annihilates both and ends the process.</p>
<pre><code class="language-par">def f: A = chan return: chan A {
  let a: A = ...
  return &lt;&gt; a
}
</code></pre>
<p>Rewrite rules for all expressions can be found at their respective rules (for <a href="statements/../expressions/application.html">applications</a> they are grouped at the start).</p>
<h2 id="the-break-command"><a class="header" href="#the-break-command">The Break Command</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BreakCommand</em> : <em>Receiver</em> <code>!</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#the-continue-command">Dual</a>
| <a href="statements/../types.html#the-bottom-type">Destructs Type</a>
| <a href="statements/../types.html#the-unit-type">Destructs Channel</a>
</sup></em></p>
<p>A break command destructs a <code>?</code> and ends the process.
It is used with <code>chan</code>, as destructing a <code>?</code> is constructing its dual <code>!</code> there.</p>
<pre><code class="language-par">def unit: ! = chan bottom: ? {
  bottom!
}
</code></pre>
<h2 id="the-continue-command"><a class="header" href="#the-continue-command">The Continue Command</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ContinueCommand</em> : <em>Receiver</em> <code>?</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#the-break-command">Dual</a>
| <a href="statements/../types.html#the-unit-type">Destructs Type</a>
| <a href="statements/../types.html#the-bottom-type">Destructs Channel</a>
| <a href="statements/../patterns.html#the-unit-pattern">Pattern</a>
| <a href="statements/../expressions/construction.html#the-unit-expression">Constructing Expression</a>
</sup></em></p>
<p>A continue is used to destruct a <code>!</code>:</p>
<pre><code class="language-par">dec drop_bool : [Bool] !

let b1: Bool = ...
let b2: Bool = ...
// get rid of b1
do {
  // drop_bool(b1) returns !
  // this is destructed by ?
  drop_bool(b1)?
} in b2
</code></pre>
<h2 id="send-commands"><a class="header" href="#send-commands">Send Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SendCommand</em> : <em>Receiver</em> <code>(</code> <a href="statements/../expressions.html"><em>ExpressionList</em></a> <code>)</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#receive-commands">Dual</a>
| <a href="statements/../types.html#function-types">Destructs Type</a>
| <a href="statements/../types.html#pair-types">Destructs Channel</a>
| <a href="statements/../expressions/application.html#function-calls">Expression</a>
| <a href="statements/../expressions/construction.html#function-expressions">Constructing Expression</a>
</sup></em></p>
<p>Having multiple expressions between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">// the command
r(x, y)
// is equivalent to
r(x)(y)
</code></pre>
<p>A send command can destruct (“call”) a function:</p>
<pre><code class="language-par">do {
  let b: Bool = .true!
  let negate: [Bool] Bool = ...

  // call negate
  negate(b)
  // negate is now the negation of b
} in negate
// evaluates to .false!
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing <code>[A] chan B</code> to dually construct <code>(A) B</code></p>
<pre><code class="language-par">def true_false: (Bool) Bool = chan return: [Bool] chan Bool {
  return(.true!)
  // return is now a chan Bool
  return &lt;&gt; .false!
}
</code></pre>
<h2 id="receive-commands"><a class="header" href="#receive-commands">Receive Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SendCommand</em> : <em>Receiver</em> <code>[</code> <a href="statements/../patterns.html"><em>PatternList</em></a> <code>]</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#send-commands">Dual</a>
| <a href="statements/../types.html#pair-types">Destructs Type</a>
| <a href="statements/../types.html#function-types">Destructs Channel</a>
| <a href="statements/../patterns.html#pair-patterns">Pattern</a>
| <a href="statements/../expressions/construction.html#pair-expressions">Constructing Expression</a>
</sup></em></p>
<p>Having multiple patterns between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">// the pattern
r[p, q]
// is equivalent to
r[p][q]
</code></pre>
<p>A receive command can destruct a pair:</p>
<pre><code class="language-par">dec reverse : [type A, B] [(A) B] (B) A
def reverse = [type A, B] [pair] do {
  // receive first value
  pair[first]
  // if pair was (a) b :
  // first is now a
  // pair is now b
} in (pair) first
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing <code>(A) chan B</code> to dually construct <code>[A] B</code></p>
<pre><code class="language-par">def negate: [Bool] Bool = chan return: (Bool) chan Bool {
  // receive the argument
  return[arg]
  // return is now a chan Bool
  return &lt;&gt; arg {
    .true! =&gt; .false!
    .false! =&gt; .true!
  }
}
</code></pre>
<h2 id="signal-commands"><a class="header" href="#signal-commands">Signal Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SignalCommand</em> : <em>Receiver</em> <a href="statements/../types.html"><em>Label</em></a></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#match-commands">Dual</a>
| <a href="statements/../types.html#choice-types">Destructs Type</a>
| <a href="statements/../types.html#either-types">Destructs Channel</a>
| <a href="statements/../expressions/application.html#choice-selections">Expression</a>
| <a href="statements/../expressions/construction.html#choice-constructions">Constructing Expression</a>
</sup></em></p>
<p>A signal command can destruct a choice:</p>
<pre><code class="language-par">type Stream&lt;T&gt; = iterative {
  .close =&gt; !
  .next =&gt; (T) self
}

dec first_two : [type T] [Stream&lt;T&gt;] (T, T)!
def first_two = [type T] [stream] do {
  // signal next
  stream.next
  // stream is now (T) Stream&lt;T&gt;
  stream[first]
  // stream is now again Stream&lt;T&gt;

  // combine both operations
  stream.next[second]

  // close the stream
  stream.close?
} in (first, second)!
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing a choice type to dually construct an either type:</p>
<pre><code class="language-par">// chan Bool is equal to
type ChanBool = {
  .true =&gt; ?
  .false =&gt; ?
}

def just_true: Bool = chan return: ChanBool {
  // signal true
  return.true
  // return is now ?
  return!

  // return.true! would have been equally valid
}
</code></pre>
<h2 id="match-commands"><a class="header" href="#match-commands">Match Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MatchCommand</em> : <em>Receiver</em> <code>{</code> (<a href="statements/../types.html"><em>Label</em></a> (<code>(</code> <a href="statements/../expressions/construction.html#choice-constructions"><em>ReceivePatterns</em></a> <code>)</code>)<sup>*</sup> <code>!</code><sup>?</sup> <code>=&gt;</code> <code>{</code> <a href="statements/../statements.html"><em>Process</em></a> <code>}</code>)<sup>*</sup> <code>}</code></p>
</blockquote>
<!-- maybe also allow statement instead of {process} -->
<p><em><sup>
<a href="statements/commands.html#signal-commands">Dual</a>
| <a href="statements/../types.html#either-types">Destructs Type</a>
| <a href="statements/../types.html#choice-types">Destructs Channel</a>
| <a href="statements/../expressions/application.html#either-destructions">Expression</a>
| <a href="statements/../expressions/construction.html#either-selections">Constructing Expression</a>
</sup></em></p>
<p>Patterns in <code>(...)</code> after the label are equivalent to a receive command in the body:</p>
<pre><code class="language-par">x {
  .label(a) =&gt; { rest... }
}
// is equivalent to
x {
  .label =&gt; {
    x[a]
    rest...
  }
}
</code></pre>
<p><code>(a, b)</code> is also equivalent to <code>(a)(b)</code> here.</p>
<p>Similarly, a <code>!</code> afterwards is equivalent to a continue in the body:</p>
<pre><code class="language-par">x {
  .label(...)! =&gt; { rest... }
}
// is equivalent to
x {
  .label(...) =&gt; {
    x?
    rest...
  }
}
</code></pre>
<p>A match command can destruct an either type:</p>
<pre><code class="language-par">def drop_bool: [Bool] ! = [b] do {
  // match on b
  b {
    .true =&gt; {
      // b is now !
      b?
    }
    // combine both 
    // (moving ? over =&gt; makes it !)
    .false! =&gt; {}
  }
} in !
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing an either type to dually construct a choice type:</p>
<pre><code class="language-par">// choice of two
type BoolChoice&lt;A, B&gt; = {
  .true =&gt; A
  .false =&gt; B
}

// dual type
type ChanBoolChoice&lt;A, B&gt; = either {
  .true chan A
  .false chan B
}

dec negate_choice : BoolChoice&lt;Bool, Bool&gt;
def negate_choice = chan return: ChanBoolChoice&lt;Bool, Bool&gt; {
  return {
    .true =&gt; {
      // return is now of type chan Bool
      return.false!
    }
    .false =&gt; { return.true! }
  }
}
</code></pre>
<h2 id="recursive-commands"><a class="header" href="#recursive-commands">Recursive Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SendCommand</em> :<br />
      <em>Receiver</em> <code>unfounded</code><sup>?</sup> <code>begin</code> <em>LoopLabel</em><sup>?</sup></p>
<p><em>LoopCommand</em> :<br />
      <em>Receiver</em> <code>loop</code> <em>LoopLabel</em><sup>?</sup></p>
<p><em>LoopLabel</em> :<br />
      <code>:</code> <a href="statements/../lexical.html#names">ID</a></p>
</blockquote>
<p><em><sup>
<a href="statements/../types.html#recursive-types">Destructs Type</a>
| <a href="statements/../types.html#iterative-types">Destructs Channel</a>
| <a href="statements/../expressions/application.html#recursive-destructions">Expression</a>
</sup></em></p>
<p>A <code>loop</code> corresponds to the innermost <code>begin</code> with the same loop label. <code>loop</code> without a label can only correspond to <code>begin</code> without a label.</p>
<div class="warning">
<p>Due to totality, <code>loop</code> can only be called on a descendant of the value <code>begin</code> was called on. I.e. on a value which type is a “<code>self</code>” correponding to the recursive type which <code>begin</code> was called on.</p>
<p>If that is not the case, the unsafe <code>unfounded begin</code> must be used, which leaves it up to the programmer to ensure totality.</p>
<p>For examples, see recursive destructing <a href="statements/../expressions/application.html#recursive-destructions">expressions</a>.</p>
</div>
<p>A recursive command can destruct a recursive type:</p>
<pre><code class="language-par">def list_and: [List&lt;Bool&gt;] Bool = [list] do {
  let result: Bool = .true!

  // destruct list recursively
  list begin {
    // after begin, list is of type
    // either { .empty!, .item(Bool) List&lt;Bool&gt; }
    // notice the absence of recursive
    .item =&gt; {
      // list is now of type (Bool) List&lt;Bool&gt;
      list[b]
      b {
        .true! =&gt; {}
        .false! =&gt; {
          drop_bool(result)?
          // reassign result here
          let result: Bool = .false!
        }
      }
      // list is now of type List&lt;Bool&gt;
      // go to begin
      list loop
    }
    .empty! =&gt; {}
  }
} in result
</code></pre>
<p>Note that</p>
<pre><code class="language-par">.item =&gt; {
  list[b]
  ...
}
</code></pre>
<p>could have been replaced with</p>
<pre><code class="language-par">.item(b) =&gt; {
  ...
}
</code></pre>
<p>A very important concept is that all values which were consumed between <code>begin</code> and <code>loop</code> must be reassigned (like <code>result</code> in the example). This even allows variables to change in between the iterations:</p>
<pre><code class="language-par">def first_nats: [Nat] List&lt;Nat&gt; = [n] do {
  // initialize "mutable" value
  let list: List&lt;Nat&gt; = .empty!
  n begin {
    .zero! =&gt; {
      // also reassign, but for after `in`
      let list = .item(.zero!) list
    }
    .succ pred =&gt; {
      // here pred gets reassigned
      let (pred, p)! = copy_nat(pred)
      // and list gets reassigned as well
      let list = .item(.succ p) list
      pred loop
    }
  } 
} in list
</code></pre>
<p>A recursive command can also be used with <code>chan</code>: Destructing a recursive (here: either) type to dually construct an iterative (here: choice) type:</p>
<pre><code class="language-par">// chan Stream&lt;Bool&gt; is
type ChanStreamBool = recursive either {
  .close?
  .next[T] self
}

def alt_true_false: Stream&lt;Bool&gt; = chan return: ChanStreamBool {
  let next: Bool = .true!
  // begin recursive destruction
  return begin {
    // return is now of type 
    // either { .close?, .next[T] ChanStreamBool }
    // again, notice the absence of recursive
    .close =&gt; {
      // return is now ?
      // handle next first
      drop_bool(next)?
      return!
    }
    .next =&gt; {
      // return is now of type [T] ChanStreamBool
      // handle next first
      next {
        .true! =&gt; {
          let yield = .true!
          let next = .false!
        }
        .false! =&gt; {
          let yield = .false!
          let next = .true!
        }
      }
      return(yield)
      // return is now of type ChanStreamBool
      return loop

      // return(yield) loop would have been equally valid
    }
  }
}

// in expression syntax:
def alt_true_false: Stream&lt;Bool&gt; = do {
  let next: Bool = .true!
} in begin {
  .close =&gt; drop_bool(next),
  .next =&gt; let (yield: Bool, next: Bool)! = next {
    .true! =&gt; (.true!, .false!)!
    .false! =&gt; (.false!, .true!)!
  } in (yield) loop
}
</code></pre>
<h2 id="send-type-commands"><a class="header" href="#send-type-commands">Send Type Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SendTypeCommand</em> : <em>Receiver</em> <code>(</code> <code>type</code> <a href="statements/../lexical.html#names"><em>ID_List</em></a> <code>)</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#receive-type-commands">Dual</a>
| <a href="statements/../types.html#universal-types">Destructs Type</a>
| <a href="statements/../types.html#existential-types">Destructs Channel</a>
| <a href="statements/../expressions/application.html#universal-specializations">Expression</a>
| <a href="statements/../expressions/construction.html#universal-constructions">Constructing Expression</a>
</sup></em></p>
<p>Having multiple types between <code>(</code> and <code>)</code> is just syntax sugar:</p>
<pre><code class="language-par">// the command
r(type T, U)
// is equivalent to
r(type T)(type U)
</code></pre>
<p>A send command can destruct (“specialize”) a universal type:</p>
<pre><code class="language-par">def id: [type T] [T] T = [type T] [x] x

def just_true = do {
  let b: Bool = .true!
  
  let f = id
  // specialize f
  f(type Bool)
  // f is now of type [Bool] Bool
  f(b)
  // f is now .true!
} in f
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing <code>[type X] chan T</code> to dually construct <code>(type X) T</code></p>
<pre><code class="language-par">type Any = (type T) T

def true_as_any: Any = chan return: [type T] chan T {
  return(type Bool)
  // return is now type chan Bool
  return.true!

  // could have been combined to
  // return (type Bool) .true!
}
</code></pre>
<h2 id="receive-type-commands"><a class="header" href="#receive-type-commands">Receive Type Commands</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SendTypeCommand</em> : <em>Receiver</em> <code>[</code> <code>type</code> <a href="statements/../lexical.html#names"><em>ID_List</em></a> <code>]</code></p>
</blockquote>
<p><em><sup>
<a href="statements/commands.html#send-type-commands">Dual</a>
| <a href="statements/../types.html#existential-types">Destructs Type</a>
| <a href="statements/../types.html#universal-types">Destructs Channel</a>
| <a href="statements/../patterns.html#existential-patterns">Pattern</a>
| <a href="statements/../expressions/construction.html#existential-constructions">Constructing Expression</a>
</sup></em></p>
<p>Having multiple names between <code>[</code> and <code>]</code> is just syntax sugar:</p>
<pre><code class="language-par">// the pattern
r[type X, Y]
// is equivalent to
r[type X][type Y]
</code></pre>
<p>A receive command can destruct an existential type:</p>
<pre><code class="language-par">def complicated_any_id: (Any) Any = [x] do {
  // receive the type
  x[type X]
  // x is now of type X
  let y: X = x
} in (type X) y
</code></pre>
<p>It can also be used with <code>chan</code>: Destructing <code>(type T) chan R</code> to dually construct <code>[T] R</code></p>
<pre><code class="language-par">def id: [type T] [T] T = chan return: (type T) (T) chan T {
  return[type T]
  // return is now of type (T) chan T
  return[x]
  // return is now of type chan T
  return &lt;&gt; x
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-1"><a class="header" href="#future-1">Future</a></h1>
<p>Here the
planned features are listed. You can read more and even actively help the language grow on the Par <a href="https://discord.gg/8KsypefW99">Discord</a></p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p><sup>Priority: Essential</sup></p>
<h2 id="replicables"><a class="header" href="#replicables">Replicables</a></h2>
<p><sup>Priority: Essential</sup></p>
<h2 id="extensible-io-via-rust-controlled-objects"><a class="header" href="#extensible-io-via-rust-controlled-objects">Extensible I/O via Rust-controlled objects</a></h2>
<p><sup>Priority: Essential</sup></p>
<h2 id="non-determinism"><a class="header" href="#non-determinism">Non-determinism</a></h2>
<p><sup>Priority: Essential</sup></p>
<h2 id="tagged-types"><a class="header" href="#tagged-types">Tagged types</a></h2>
<p><sup>Priority: High</sup></p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p><sup>Priority: High</sup></p>
<h2 id="powerful-pattern-matching"><a class="header" href="#powerful-pattern-matching">Powerful pattern matching</a></h2>
<p><sup>Priority: Medium</sup></p>
<h2 id="records"><a class="header" href="#records">Records</a></h2>
<p><sup>Priority: Medium</sup></p>
<h2 id="reactive-values"><a class="header" href="#reactive-values">Reactive values</a></h2>
<p><sup>Priority: Low</sup></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>Thank you for reading the Par documentation!</p>
<p>Read about more technical topics in the next chapters.</p>
<h2 id="contributors"><a class="header" href="#contributors">Contributors</a></h2>
<p>TODO</p>
<h2 id="influences"><a class="header" href="#influences">Influences</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>The grammar of Par is declared in <em>Lexer</em> and <em>Syntax</em> blocks. It uses the following notation:</p>
<ul>
<li>
<p>Sequences of capital letters like DIGIT represent lexer tokens</p>
</li>
<li>
<p>Italic names in CamelCase like <em>Item</em> represent parser nonterminals</p>
</li>
<li>
<p>Character sequences in monospace like <code>type</code> represent literals</p>
</li>
<li>
<p>Characters may be represented using escape sequences, like \n</p>
</li>
<li>
<ul>
<li>x<sup>?</sup> means x, zero or once</li>
<li>x<sup>*</sup> means x, zero or more</li>
<li>x<sup>+</sup> means x, once or more</li>
<li>x<sup>a..b</sup> means at least a and at most b of x</li>
</ul>
</li>
<li>
<p>x | y means either x or y</p>
</li>
<li>
<p>[ and ] group characters together, like [<code>x</code> <code>X</code>] or [<code>a</code>-<code>z</code>]</p>
</li>
<li>
<p>character sequences (and groups of them) can be negated by ~, like ~\n</p>
</li>
<li>
<p>( and ) group arbitrary rules for precedence</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
